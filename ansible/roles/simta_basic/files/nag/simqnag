#!/bin/bash
# nag to check simta spool count & check if simta owns all in /var/spool/simta

qdir=/var/spool/simta
name=simqnag
confdir=/usr/local/collaboration/nag
slowqmax=9000
jailqmax=0
fastqmax=1000
localqmax=2
deadqmax=1
# in minutes
piddelay=60
tmpsave=300
maxsnum=10
# age in minutes for fast queue files
fastqage=120
# number of 4h messages to ignore in fast q
fastqoldmax=2

. /usr/libexec/comint/setup

# test for disabled flag
if [[ $disabled ]]; then
    exit 1
fi

# test for simta spool directory
if ! [[ -d /var/spool/simta ]]; then
    exit 1
fi

# test for simta user
id simta >&/dev/null
if [[ $? -ne 0 ]]; then
    exit 1
fi

localqnum=$(ls ${qdir}/local | grep ^E | wc -l)
if [[ $localqnum -gt $localqmax ]]; then
    echo "$name: [CRITICAL] $host local queue contains $localqnum messages!" | eval ${notifycmd_error} ${notifywho_error}
    exit 1
fi

# test for running simta daemon
pgrep -P 1 -u simta -x simta >&/dev/null
if [[ $? -ne 0 ]]; then
    exit 1
fi

# check how many messages,  page if over water mark

slowqnum=$(ls ${qdir}/slow | grep ^E | wc -l)
if [[ ${slowqnum} -gt ${slowqmax} ]]; then
    echo "$name: [WARNING] $host slow queue contains $slowqnum messages!" | eval ${notifycmd_error} ${notifywho_error}
    $confdir/../dispatch/simqc
    exit 1
fi

fastqnum=$(ls ${qdir}/fast | grep ^E | wc -l)
if [[ $fastqnum -gt $fastqmax ]]; then
    echo "$name: [WARNING] $host fast queue contains $fastqnum messages!" | eval ${notifycmd_error} ${notifywho_error}
    $confdir/../dispatch/simqc
    exit 1
fi

jailqnum=$(find ${qdir}/slow -ignore_readdir_race -type f -mmin +1 -name 'E*' | xargs grep -l '^J2$' | wc -l)
if [[ $jailqnum -gt $jailqmax ]]; then
    echo "$name: [WARNING] $host slow queue contains $jailqnum jailed messages!" | eval ${notifycmd_error} ${notifywho_error}
    $confdir/../dispatch/simqc
    exit 1
fi

# check if simta is owner of all files under /var/spool/simta, if not page
cd $qdir
find ./dead ./fast ./local ./slow -ignore_readdir_race \! -user simta -fls $tmpdir/owner
if [[ $? -eq 0 && -s $tmpdir/owner ]]; then
    echo "$name: [CRITICAL] files in /var/spool/simta not owned by simta on $host, check $tmpdir/owner" | eval ${notifycmd_error} ${notifywho_error}
fi

# find files in fast queue that are older than $fastqage minutes old
fastqold=$(find ${qdir}/fast -ignore_readdir_race -type f -name "E*" -mmin +${fastqage} | wc -l)
if [[ $fastqold -gt $fastqoldmax ]]; then
    echo "$name: [WARNING] $host fast queue contains $fastqold messages over $fastqage minutes old!" | eval ${notifycmd_error} ${notifywho_error}
    [[ $DEBUG -eq 0 ]] && $confdir/../dispatch/old_connection fastqage=$fastqage
    [[ $DEBUG -eq 1 ]] && echo "$confdir/../dispatch/old_connection -d fastqage=$fastqage"
    exit 1
fi

# check for orphan pids in fast
pgrep simta > $tmpdir/simpids

if [[ -s $tmpdir/simpids ]]; then
    for x in $(find ${qdir}/fast -ignore_readdir_race -type f -amin +"$piddelay" | awk -F. '{ print $NF }' | sort -u); do
        grep -q $x $tmpdir/simpids
        if [[ $? -eq 1 ]]; then
            ls ${qdir}/fast/*.$x >> $tmpdir/orphans
        fi
    done
fi

if [[ -s $tmpdir/orphans ]]; then
    echo "$name: [CRITICAL] $host pid orphans in fast queue. check $tmpdir/orphans" | eval ${notifycmd_error} ${notifywho_error}
fi

# check for growing slow queue
newsnum=$(find $qdir/slow -ignore_readdir_race -name "D*" -mmin +15 -mmin -30 | grep -c D*)
if [[ $newsnum -gt $maxsnum ]]; then
    echo "$name: [WARNING] $host slow queue has $newsnum new messages" | eval ${notifycmd_error} ${notifywho_error}
    $confdir/../dispatch/simqc
fi

# cleanup
if [[ ! -s $tmpdir/orphans && ! -s $tmpdir/owner ]]; then
    cleanup
fi

exit 0
