#!/usr/bin/perl

use strict;
use warnings;
use 5.014;

use Digest::SHA qw/sha256_hex/;
use Time::Piece;


# There's a lot of ancient data, let's ignore anything more than two years old
my $cutoffdate = localtime->strftime('%Y%m%d') - 20000;

if (@ARGV == 1) {
    open(STDIN, '<', $ARGV[0]) or die "Failed to open $ARGV[0]: $!";
}

my @ignores;
if (open(my $fh, '<', '/etc/mail/clamav.badurl')) {
    while (my $url = <$fh>) {
        chomp $url;
        push @ignores, $url;
    }
}

while (<>) {
    next unless $_;

    # Skip comments
    next if m/^#/;

    # ClamAV does not handle at signs well
    next if m/@/;

    my ($url, $date) = split /,/;
    next if $date < $cutoffdate;
    next if grep {$_ eq $url} @ignores;

    # unescape URL
    $url =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
    # reescape spaces
    $url =~ s/ /%20/g;

    # Add / to bare hostnames
    $url .= '/' unless $url =~ m|/|;

    # Change port numbers to path components (what the hell, ClamAV?)
    $url =~ s|([^/]):(\d+)/|$1/$2/|;

    my $prefix = $url;

    # Remove fragments
    $url =~ s|/*#[^/]*$||;

    # This is our URL hash
    say 'S1:F:', sha256_hex($url);

    # Calculate prefix hashes
    #
    ## Being over-inclusive is okay, since this match is necessary but not
    ## sufficient.

    # Remove filenames
    $prefix =~ s|[^/]+$||;

    # Limit to three hostname components
    $prefix =~ s|[^/]+\.([^/]+\.[^/]+\.[^/]+/)|$1|;

    say 'S1:P:', substr(sha256_hex($prefix), 0, 8);

    # Loop to remove path components
    while ( $prefix =~ m|/.*/| ) {
        $prefix =~ s|/[^/]*$||;
	say 'S1:P:', substr(sha256_hex($prefix), 0, 8);
    }
}

