From 98cc60056ac41e10664364edbe2fecc7d47ce76b Mon Sep 17 00:00:00 2001
From: Paul Arthur <paul.arthur@flowerysong.com>
Date: Sun, 26 May 2019 07:19:56 +0000
Subject: [PATCH] Fix buffer length check

It is possible for bm->offset to be negative and (offset + bm->offset)
to be positive, in which case the bounds check was incorrectly skipped.

    Program terminated with signal SIGSEGV, Segmentation fault.
    #0  0x00007fea90598db0 in cli_bcomp_compare_check (
        f_buffer=0x7fea5c9e3a3e <error: Cannot access memory at address 0x7fea5c9e3a3e>, f_buffer@entry=0x7fea5c98c1ba "\001\030\001\030",
        buffer_length=buffer_length@entry=2590, offset=<optimized out>,
        bm=bm@entry=0x7fea7289f9c8) at matcher-byte-comp.c:720
    720                     case 4: bin_value =   (uint32_t) le32_to_host( *(uint32_t*) f_buffer); break;
---
 libclamav/matcher-byte-comp.c | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/libclamav/matcher-byte-comp.c b/libclamav/matcher-byte-comp.c
index 0ef5e52..9ade2c5 100644
--- a/libclamav/matcher-byte-comp.c
+++ b/libclamav/matcher-byte-comp.c
@@ -579,16 +579,13 @@ cl_error_t cli_bcomp_compare_check(const unsigned char* f_buffer, size_t buffer_
     opt = bm->options;
 
     /* ensure we won't run off the end of the file buffer */
-    if (bm->offset > 0) {
-        if (!((offset + bm->offset + byte_len <= length))) {
-            bcm_dbgmsg("cli_bcomp_compare_check: %u bytes requested at offset %zu would go past file buffer of %u\n", byte_len, (offset + bm->offset), length);
-            return CL_CLEAN; 
-        }
-    } else {
-        if (!(offset + bm->offset > 0)) {
-            bcm_dbgmsg("cli_bcomp_compare_check: negative offset would underflow buffer\n");
-            return CL_CLEAN; 
-        }
+    if (!((offset + bm->offset + byte_len <= length))) {
+        bcm_dbgmsg("cli_bcomp_compare_check: %u bytes requested at offset %zu would go past file buffer of %u\n", byte_len, (offset + bm->offset), length);
+        return CL_CLEAN;
+    }
+    if (!(offset + bm->offset > 0)) {
+        bcm_dbgmsg("cli_bcomp_compare_check: negative offset would underflow buffer\n");
+        return CL_CLEAN;
     }
 
     /* jump to byte compare offset, then store off specified bytes into a null terminated buffer */
-- 
1.8.3.1

